RISC-V assembly (easy)


Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?


R: The riscv calling convention determines the arguments are passed using registers a0-a7.
The first argument (the format string) is passed in a0, and the second argument (f call) is inline optimized to the constant 12 and passed in a1 register. the number 13 is passed in a2 register.

Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
R: The text section starts at address 0. The call function to f doesn't exist due to the inline compiler optimization and the call to g also is statically optimized to a constant value ¯\_(ツ)_/¯. 
But the call to printf is at address 0x34 -> `34:	61a080e7          	jalr	1562(ra) # 64a <printf>`

At what address is the function printf located?
R: Printf is located at address 0x00000000000064a (0x34 + 1562 -4 from jalr	1562(ra) at address 0x34 ) 

What value is in the register ra just after the jalr to printf in main?
R: In riscv the ra register is the return address of a call (instead of pushing the return address into the stack in x86).
The jalr instruction saves the return address in the ra (could be any register but convention chooses ra using it as destination and source at the same time https://jemu.oscc.cc/JALR).
so the value of ra just after the jalr to printf in main is 0x38.


Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

Here's a description of little- and big-endian and a more whimsical description.

R: The code above returns `HE110 World` 72='r' 6c='l' 64='d' ; 57616 = 0xE110. RISC-V uses little-endian

In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

    printf("x=%d y=%d", 3);

R: In my program it prints y=1. But the value printed is the content of the register a2 that was not set during the call to printf. Each access to unpassed arguments follows the calling convention until values are accessed from the stack eventually.  
Knowledge of behaviour is useful when exploiting format string vulnerabilities 
      


Below my call.asm file:

user/_call:     file format elf64-littleriscv


Disassembly of section .text:

0000000000000000 <g>:
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int g(int x) {
   0:	1141                	addi	sp,sp,-16
   2:	e422                	sd	s0,8(sp)
   4:	0800                	addi	s0,sp,16
  return x+3;
}
   6:	250d                	addiw	a0,a0,3
   8:	6422                	ld	s0,8(sp)
   a:	0141                	addi	sp,sp,16
   c:	8082                	ret

000000000000000e <f>:

int f(int x) {
   e:	1141                	addi	sp,sp,-16
  10:	e422                	sd	s0,8(sp)
  12:	0800                	addi	s0,sp,16
  return g(x);
}
  14:	250d                	addiw	a0,a0,3
  16:	6422                	ld	s0,8(sp)
  18:	0141                	addi	sp,sp,16
  1a:	8082                	ret

000000000000001c <main>:

void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0
  2c:	7c850513          	addi	a0,a0,1992 # 7f0 <malloc+0xe8>
  30:	00000097          	auipc	ra,0x0
  34:	61a080e7          	jalr	1562(ra) # 64a <printf>
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	auipc	ra,0x0
  3e:	298080e7          	jalr	664(ra) # 2d2 <exit>

0000000000000042 <_main>:
//
// wrapper so that it's OK if main() does not call exit().
//
void
_main()
{
  42:	1141                	addi	sp,sp,-16
  44:	e406                	sd	ra,8(sp)
  46:	e022                	sd	s0,0(sp)
  48:	0800                	addi	s0,sp,16
  extern int main();
  main();
  4a:	00000097          	auipc	ra,0x0
  4e:	fd2080e7          	jalr	-46(ra) # 1c <main>
  exit(0);
  52:	4501                	li	a0,0
  54:	00000097          	auipc	ra,0x0
  58:	27e080e7          	jalr	638(ra) # 2d2 <exit>


